# 线程&进程&调度器

## 目的

​	通过实现一个简单的用户态pthread库，学习线程、进程的相关概念与调度器的相关知识

## 线程与进程

### 什么是线程

​	线程指的是进程中**单一的一条控制流**，是OS可以调度的最小单位，在OS中由TCB（Thread Control Block）存储线程的相关信息。描述线程需要的信息相较进程来说要少很多，仅需要**栈、寄存器组、线程状态**等，同一进程下的多个线程有同一个虚拟内存空间（线程上下文中并不包含页表），因此线程较进程而言更加轻量。

### 什么是进程

​	进程是线程的容器，在线程的基础上多了很多上下文信息，在OS中由PCB（Process Control Block）描述进程的信息。进程的上下文不仅包括栈、寄存器组、状态，**还包括程序的IO状态、文件描述符与读写指针、事件和信号的相关信息、虚拟地址空间等**。

### 用户级线程

```c
// user-thread

// TCB结构体
typedef struct thread_t {
    int tid;
    enum {
        RUNNING,
        SLEEPING,
        READY,
    } state;
    int64_t rsp;
    int64_t stack[1024];  // 4kb stack
	//寄存器组的上下文信息简单存储在栈中
} thread_t;

// 存储当前运行的线程与线程列表
thread_t* current_thread;
thread_t* threads_list[THREADS_NR];

// 为一个新线程初始化栈
extern void context_init(int64_t* rsp);

// 创建一个新线程，并添加到线程列表中
int thread_create(thread_t* thread, void* (*routine)(void*)) {
    // 为新线程找slot, 并将下标作为线程的tid
    unsigned int i;
    for (i = 0; i < THREADS_NR; i++) {
        if (threads_list[i] == 0) {
            threads_list[i] = thread;
            break;
        }
    }
    if (i == THREADS_NR)
        return -1;
    // 初始化线程的信息
    thread->tid = i;
    thread->state = READY;
    thread->stack[1023] = (int64_t)routine;
    thread->rsp = (int64_t)&(thread->stack[1022]);
    context_init(&thread->rsp);
    return 0;
}

// 线程休眠
int thread_park() {
    current_thread->state = SLEEPING;
    schedule();
    return 0;
}

// 线程唤醒
int thread_unpark(int tid) {
    threads_list[tid]->state = READY;
    return 0;
}
```

## 上下文切换

### 理解

​	控制流的执行可以理解为一个状态机的状态转换过程，而**描述状态所需要的信息就是上下文（Context）**，通过上下文切换（Context Switch）即可让CPU从一个控制流转到另一个控制流执行，极大提高了CPU的利用率

### Context Switch的实现

```assembly
#context.s
	
#context switch 函数
#调用时原型为 void context_switch(int64_t* from, int64_t* to)
	.file	"conotext.c"
	.text
	.globl	context_switch
	.type	context_switch, @function
context_switch:
.LFB0:
	.cfi_startproc
	.cfi_def_cfa_offset 16
	pushq  	%rbp
	.cfi_offset 6, -16
	.cfi_def_cfa_register 6
	# 保存上下文到当前线程的栈中
	movq 	%rsp, %rbp
	subq	$120, %rsp
	movq	%rsp, (%rdi)
	movq	%rax, -8(%rsp)
	movq	%rbx, -16(%rsp)
	movq	%rcx, -24(%rsp)
	movq	%rdx, -32(%rsp)
	movq	%rdi, -40(%rsp)
	movq	%rsi, -48(%rsp)
	movq	%rbp, -56(%rsp)
	movq	%r8 , -64(%rsp)
	movq	%r9 , -72(%rsp)
	movq	%r10, -80(%rsp)
	movq	%r11, -88(%rsp)
	movq	%r12, -96(%rsp)
	movq	%r13, -104(%rsp)
	movq	%r14, -112(%rsp)
	movq	%r15, -120(%rsp)
	
	# 切换栈，并从另一个线程的栈中恢复出上下文信息
	movq 	(%rsi), %rsp
	movq	-8(%rsp), %rax
	movq	-16(%rsp), %rbx
	movq	-24(%rsp), %rcx
	movq	-32(%rsp), %rdx
	movq	-40(%rsp), %rdi
	movq	-48(%rsp), %rsi
	movq	-56(%rsp), %rbp
	movq	-64(%rsp), %r8 
	movq	-72(%rsp), %r9 
	movq	-80(%rsp), %r10
	movq	-88(%rsp), %r11
	movq	-96(%rsp), %r12
	movq	-104(%rsp), %r13
	movq	-112(%rsp), %r14
	movq	-120(%rsp), %r15
	
	leave
	nop
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	context_switch, .-context_switch
	
# context_init函数，为新线程初始化栈
	.globl	context_init
	.type	context_init, @function
context_init:
.LFB1:
	.cfi_startproc
	.cfi_def_cfa_offset 16
	pushq 	%rbp
	.cfi_offset 6, -16
	.cfi_def_cfa_register 6
	movq 	%rsp, %rbp
	movq    (%rdi), %rsp
	subq	$120,  %rsp
	movq	$0, -8(%rsp)	
	movq	$0, -16(%rsp)	
	movq	$0, -24(%rsp)	
	movq	$0, -32(%rsp)	
	movq	$0, -40(%rsp)	
	movq	$0, -48(%rsp)	
	
	pushq	(%rdi)
	popq	-56(%rsp)	
	
	movq	$0, -64(%rsp)
	movq	$0, -72(%rsp)
	movq	$0, -80(%rsp)
	movq	$0, -88(%rsp)
	movq	$0, -96(%rsp)
	movq	$0, -104(%rsp)
	movq	$0, -112(%rsp)
	movq	$0, -120(%rsp)
	movq 	%rsp, (%rdi)

	leave
	nop
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE1:
	.size	context_init, .-context_init
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
```

## 调度器

### 什么是调度器

​	上文中已经实现了在线程之间切换，但是究竟从当前线程切换到哪一个线程依然是个问题。调度器用以解决这个问题。

### MLFQ

#### 什么是MLFQ

​	MLFQ，即多级反馈队列（multi-level feedback queue），是一种调度算法，利用多个优先级队列来同时兼顾响应时间与轮转时间

#### MLFQ的原则

-   **规则 1:   如果两个线程中A的优先级高于B的优先级，则选择A**
-   **规则 2： 如果两线程优先级相同，AB线程以RR方式交替运行**

-   **规则 3： 当一个新线程产生，它将被置于优先级最高的队列中**

-   **规则 4:  当一个线程用完了它在该队列中的时间片，将会被降级到更低一级的队列中**

-   **规则 5: 每隔一段时间，进行一次boosting priority，将所有线程提到最高优先级**

![image-20221021233541726](../picture/MLFQ)

>   ​	在阶段A，仅有任务A执行，因此A一直执行（并由于用完时间片被放置到最低优先级的队列中）。
>
>   ​	阶段B中，任务B和C进入OS中，它们都处于最高优先级并都高于任务A，因此A不执行，B和C以Round Robin的方式轮转运行。
>
>   ​	阶段C时，任务B和任务C结束，因此任务A继续运行
>
>   ​	阶段D，任务D进入OS，它试图通过频繁、主动地放弃CPU来模拟IO-Bound任务的行为（书上说是Gaming with OS～），来欺骗调度器获取更多的时间（保持在最高优先级），但MLFQ调度器在它用完了在最高优先级的时间后，依然将它降级
>
>   ​	阶段E时，发生了一次boosting priority，所有的任务的优先级都提升到最高（防止饥饿发生），run in RR type.



### CFS

#### 什么是CFS

​	CFS，即Linux完全公平调度器，通过对不同的进程记录**virtual runtime**来进行调度。vruntime是任务当前占用CPU的总时间（runtime）再按一定的权重加成后计算得出的，CFS每次会选择当前vruntime最少的进程运行。

![image-20221021234601116](../picture/CFS)

>   ​	上图中vruntime由线段表示，下方色块代表正在执行的程序。可以看到，权重低的任务的vruntime增长的更慢，因此可以占用更多的时间（即高优先级）。同时，每次发生调度时，CFS选择的是当前vruntime最低的进程（调度器中进程信息由一棵红黑树维护，每次选择最左侧的节点），在保证公平的情况下，又实现了多优先级。

### 简单调度器的实现

```c
// 在当前线程列表中简单选择下一个READY的线程并返回
thread_t* find_next_thread() {
    thread_t* ret = current_thread;
    for (uint8_t i = current_thread->tid + 1; 
        i != current_thread->tid; i %= THREADS_NR) {
        if (threads_list[i] != 0 && threads_list[i]->state == READY) {
            ret = threads_list[i];
            break;
        }
        i++;
    }
    return ret;
}

// 找到下一个线程，修改TCB信息后进行context switch
void schedule() {
    thread_t* next = find_next_thread();
    if (current_thread->state == RUNNING)
        current_thread->state = READY;
    next->state = RUNNING;
    thread_t* old = current_thread;
    current_thread = next;
    context_switch(&(old->rsp), &(next->rsp));
    return;
}
```

## 坑：用Linux信号模拟CPU时钟中断

### 坑

​	在实现线程与调度后，想利用Linux Signal模拟CPU的定时器中断定时触发scheduler进行调度，但出现了仅接收一次信号、调度后就不再触发信号处理函数的问题。

```c
// Timer实现

#include <pthread.h>
#include <scheduler.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/signal.h>
#include <sys/time.h>
#include <time.h>
#include <timer.h>

pthread_t timer_thread;

void init_timer() {
    struct itimerval tTimer;
    memset((void*)&tTimer, 0, sizeof(tTimer));
    //定时周期1s
    tTimer.it_value.tv_sec = 0;
    tTimer.it_value.tv_usec = 1;
    tTimer.it_interval.tv_sec = 1;
    tTimer.it_interval.tv_usec = 0;
    setitimer(ITIMER_VIRTUAL, &tTimer, NULL);
}

void* timer_routine(void* args) {
    // 定时器线程屏蔽信号， 否则会导致定时器被调度...
    sigset_t mask;
    init_timer();
    sigaddset(&mask, SIGVTALRM);
    pthread_sigmask(SIG_SETMASK, &mask, NULL);
    while (1);
}

void start_timer() {
    // 启动定时器线程
    pthread_create(&timer_thread, NULL, timer_routine, NULL);
}
```

```c
// main.c
int main() {
    // 将signal handler设置为schedule
    signal(SIGVTALRM, &schedule);
    init_thread_list();
    start_timer();
    thread_t ta;
    thread_t tb;
    thread_t tc;
    thread_create(&ta, a);
    thread_create(&tb, b);
    thread_create(&tc, c);
}
```

### 原因

#### Linux信号机制

​	Linux的信号机制是在PCB中用一个位图存储当前的信号信息，每次陷入内核返回用户态之前检查，选择要处理的信号后，*调用do_signal函数修改用户栈，在栈顶添加一个handler函数，并将控制流交给该函数后返回用户态，该函数会在用户态中调用signal hanlder后再次进入内核将该信号标记为已处理。*

​	**因此，如果有一个信号未被记录为已处理，它将一直等待解除而不再接收同类型信号。**

```assembly
#Linux 0.11/kernel/system_call.s
...
ret_from_sys_call:
	...
# do_signal()在kernel/signal.c中
	# 这部分代码处理信号
	movl signal(%eax),%ebx          # 取信号位图→ebx,每1位代表1种信号，共32个信号
	movl blocked(%eax),%ecx         # 取阻塞(屏蔽)信号位图→ecx
	notl %ecx                       # 每位取反
	andl %ebx,%ecx                  # 获得许可信号位图
	bsfl %ecx,%ecx
	je 3f                           # 如果没有信号则向前跳转退出
	btrl %ecx,%ebx                  # 复位该信号(ebx含有原signal位图)
	movl %ebx,signal(%eax)          # 重新保存signal位图信息→current->signal.
	incl %ecx                       # 将信号调整为从1开始的数(1-32)
	pushl %ecx                      # 信号值入栈作为调用do_signal的参数之一
	call do_signal                  # 调用C函数信号处理程序(kernel/signal.c)
	popl %eax                       # 弹出入栈的信号值
3:	popl %eax                       # eax中含有上面入栈系统调用的返回值
	popl %ebx
	popl %ecx
	popl %edx
	pop %fs
	pop %es
	pop %ds
	iret
```

因此，实现Timer的问题在于：

​	接收到信号后，调用了Schedule，导致控制流转移，Handler并没有执行完并返回内核将该信号真正处理完，导致之后再收到信号也不会调用Schedule了。

（最后也没有想到别的方法可以模拟出CPU的时钟中断...）